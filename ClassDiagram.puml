@startuml

skinparam groupinheritance 2
hide empty member
left to right direction

package logic {
    package tokens {
        package primitive_tokens {
            class Token {
                +{abstract} {static} {method} identity() : re.Pattern
                +{method} __post_init__(self)
            }
            class _Special extends Token
            class OpenBracket extends _Special {
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class CloseBracket extends _Special {
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class EndAnchor extends _Special {
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class StartAnchor extends _Special {
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class AnyChar extends _Special {
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class Operand extends Token {
                +{abstract} {field} cast
            }
            enum Associativity {
                LTR, RTL
            }
            class Operator extends Token {
                +{abstract} {field} precedence : int
                +{field} associativity : Associativity
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{field} args_min_max : tuple[float,float]
            }
            class Binary extends Operator {
                +{field} args_min_max : tuple[float,float]
            }
            class Unary extends Operator {
                +{field} args_min_max : tuple[float,float]
            }
            class Function extends Operator {
                +{field} precedence : int
            }
            Operator <- Associativity
        }
        package operand_tokens {
            class Number extends Operand  {
                 +{abstract} {static} {method} identity() : re.Pattern
                 +{abstract} {field} cast
            }
            class Constant extends Operand
            class PIConstant extends Constant {
                 +{abstract} {static} {method} identity() : re.Pattern
                 +{abstract} {field} cast
            }
            class EConstant extends Constant {
                 +{abstract} {static} {method} identity() : re.Pattern
                 +{abstract} {field} cast
            }
        }
        package unary_tokens {
            class UnaryLeft extends Unary {
                +{field} precedence : int
                +{field} associativity : Associativity
            }
            class UnaryRight extends Unary {
                +{field} precedence : int
            }
            class UnaryMinus extends UnaryLeft {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class UnaryFactorial extends UnaryRight {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
        }
        package binary_tokens {
            class BinaryComma extends Binary {
                +{abstract} {field} precedence : int
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class BinaryPlus extends Binary {
                +{abstract} {field} precedence : int
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class BinaryMinus extends Binary {
                +{abstract} {field} precedence : int
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class BinaryMultiply extends Binary {
                +{abstract} {field} precedence : int
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class BinaryDivide extends Binary {
                +{abstract} {field} precedence : int
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class BinaryModulo extends Binary {
                +{abstract} {field} precedence : int
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class BinaryExponent extends Binary {
                +{abstract} {field} precedence : int
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
                +{field} associativity : Associativity
            }
        }
        package function_tokens {
            class FunctionModulo extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionFloorDivision extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionMin extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionMax extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionRoot extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionPow extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionLog extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionAdd extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionSubtract extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionMultiply extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionDivide extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
            }
            class FunctionSin extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
                +{field} args_min_max : tuple[float,float]
            }
            class FunctionCos extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
                +{field} args_min_max : tuple[float,float]
            }
            class FunctionTan extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
                +{field} args_min_max : tuple[float,float]
            }
            class FunctionLn extends Function {
                +{abstract} {method} operation(self,list[float],**Union[bool,str]) : float
                +{abstract} {static} {method} identity() : re.Pattern
                +{field} args_min_max : tuple[float,float]
            }
        }
    }

    package calculator {
        class Calculator {
            +{method} __init__(self)
            +{field} history : list[dict[str,str]]
            +{method} set_rules(self,**Ruleset) : None
            +{method} set_validators(self,**Callable[[list[Token]],None]) : None
            +{method} evaluate(self,str,bool,**Union[bool, str]) : float
            -{method} __to_rpn(self,list[Token]) : list[Token]
            -{method} __evaluate_rpn(self,list[Token, ...],**Union[bool, str]) : float
            -{method} __flatten(self, x) : list
        }
    }
    package ruleset {
        class Ruleset {
            +{method} __init__(self,list[Type[Token]],*,before=list[Type[Token]],after=list[Type[Token]],save=bool])
            +{field} identity : list[Type[Token]]
            +{method} enclose(self,*,before=list[Type[Token]],after=list[Type[Token]]]) : None
            +{field} regex : re.Pattern
        }
    }
    package tokenizer {
        class Tokenizer {
            +{method} __init__(self)
            +{field} tokens : list[Token]
            +{method} set_rules(self,**Ruleset) : None
            +{method} set_validators(self,**Callable[[list[Token]], None]) : None
            +{method} parse(self,str) : list[Token]
            +{method} compile(self) : None
            -{method} __verify(self) : None
            -{method} __split(self,str) : Iterator[re.Match]
            -{method} __tokenize(Iterator[re.Match]) : list[Token]
        }
    }
    package errors {
        class OperationArgumentsException
        class UnrecognizedTokenException
        class CalculationException
        class SeparatorException
    }
    Calculator *- Tokenizer
    Calculator <- Ruleset
    Calculator <- Token
    Calculator <- UnrecognizedTokenException
    Calculator <- CalculationException

    Tokenizer o- Ruleset
    Tokenizer o- Token

    Ruleset o-- Token

    operand_tokens <-[hidden]up- primitive_tokens

    primitive_tokens <-[hidden]up function_tokens
    function_tokens <-[hidden]up- binary_tokens

    unary_tokens <-[hidden]up operand_tokens
}

@enduml